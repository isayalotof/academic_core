"""
gRPC Classroom Service Implementation
Имплементация gRPC сервиса для управления аудиториями
"""

import grpc
import logging

# Import generated protobuf files
# Note: These will be generated by protoc
try:
    from proto.generated import classroom_pb2, classroom_pb2_grpc
except ImportError:
    # Graceful fallback if not yet generated
    classroom_pb2 = None
    classroom_pb2_grpc = None

from services.classroom_crud import ClassroomCRUD
from services.availability import AvailabilityService
from services.statistics import StatisticsService
from services.distance import DistanceService
from services.building_service import building_service
from utils.validators import (
    validate_classroom_data,
    validate_time_slot,
    validate_reserve_request,
    validate_pagination
)
from utils.cache import cache
from utils.metrics import track_rpc_duration
from config import config

logger = logging.getLogger(__name__)


class ClassroomServicer:
    """gRPC Classroom Service Implementation"""
    
    def __init__(self):
        self.crud = ClassroomCRUD()
        self.availability = AvailabilityService()
        self.statistics = StatisticsService()
        self.distance = DistanceService()
    
    def _build_classroom_message(self, data: dict):
        """Построить protobuf сообщение из словаря"""
        if classroom_pb2 is None:
            return None
            
        return classroom_pb2.Classroom(
            id=data.get('id', 0),
            name=data.get('name', ''),
            code=data.get('code', ''),
            building_id=data.get('building_id', 0),
            building_name=data.get('building_name', ''),
            floor=data.get('floor', 0),
            wing=data.get('wing', ''),
            capacity=data.get('capacity', 0),
            actual_area=data.get('actual_area', 0.0),
            classroom_type=data.get('classroom_type', ''),
            has_projector=data.get('has_projector', False),
            has_whiteboard=data.get('has_whiteboard', False),
            has_blackboard=data.get('has_blackboard', False),
            has_markers=data.get('has_markers', False),
            has_chalk=data.get('has_chalk', False),
            has_computers=data.get('has_computers', False),
            computers_count=data.get('computers_count', 0),
            has_audio_system=data.get('has_audio_system', False),
            has_video_recording=data.get('has_video_recording', False),
            has_air_conditioning=data.get('has_air_conditioning', False),
            is_accessible=data.get('is_accessible', True),
            has_windows=data.get('has_windows', True),
            is_active=data.get('is_active', True),
            description=data.get('description', ''),
            notes=data.get('notes', ''),
            created_at=str(data.get('created_at', '')),
            updated_at=str(data.get('updated_at', ''))
        )
    
    @track_rpc_duration('CreateClassroom')
    def CreateClassroom(self, request, context):
        """Создать новую аудиторию"""
        try:
            # Validate request
            request_data = {
                'name': request.name,
                'code': request.code,
                'building_id': request.building_id,
                'floor': request.floor,
                'wing': request.wing,
                'capacity': request.capacity,
                'actual_area': request.actual_area,
                'classroom_type': request.classroom_type,
                'has_projector': request.has_projector,
                'has_whiteboard': request.has_whiteboard,
                'has_blackboard': request.has_blackboard,
                'has_markers': request.has_markers,
                'has_chalk': request.has_chalk,
                'has_computers': request.has_computers,
                'computers_count': request.computers_count,
                'has_audio_system': request.has_audio_system,
                'has_video_recording': request.has_video_recording,
                'has_air_conditioning': request.has_air_conditioning,
                'is_accessible': request.is_accessible,
                'has_windows': request.has_windows,
                'description': request.description,
                'created_by': request.created_by if request.created_by else None
            }
            
            errors = validate_classroom_data(request_data)
            if errors:
                context.set_code(grpc.StatusCode.INVALID_ARGUMENT)
                context.set_details(f"Validation errors: {', '.join(errors)}")
                return classroom_pb2.ClassroomResponse()
            
            # Create classroom
            try:
                classroom = self.crud.create(request_data)
            except Exception as e:
                error_msg = str(e)
                # Обработка ошибок foreign key
                if 'foreign key constraint' in error_msg.lower() or 'ForeignKeyViolation' in error_msg:
                    if 'building_id' in error_msg:
                        context.set_code(grpc.StatusCode.NOT_FOUND)
                        context.set_details(f"Building with id {request_data.get('building_id')} not found")
                    else:
                        context.set_code(grpc.StatusCode.INVALID_ARGUMENT)
                        context.set_details(f"Invalid reference: {error_msg}")
                    return classroom_pb2.ClassroomResponse()
                # Другие ошибки
                logger.error(f"Error creating classroom: {e}", exc_info=True)
                context.set_code(grpc.StatusCode.INTERNAL)
                context.set_details(f"Failed to create classroom: {error_msg}")
                return classroom_pb2.ClassroomResponse()
            
            if not classroom:
                context.set_code(grpc.StatusCode.INTERNAL)
                context.set_details("Failed to create classroom")
                return classroom_pb2.ClassroomResponse()
            
            # Invalidate cache
            cache.invalidate_pattern('classrooms:*')
            cache.invalidate_pattern('available:*')
            
            logger.info(f"Created classroom: {classroom['id']}")
            
            return classroom_pb2.ClassroomResponse(
                classroom=self._build_classroom_message(classroom),
                message="Classroom created successfully"
            )
            
        except Exception as e:
            logger.error(f"Error creating classroom: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return classroom_pb2.ClassroomResponse()
    
    @track_rpc_duration('GetClassroom')
    def GetClassroom(self, request, context):
        """Получить аудиторию по ID или коду"""
        try:
            classroom = None
            
            if request.HasField('id'):
                classroom = self.crud.get_by_id(request.id)
            elif request.HasField('code'):
                classroom = self.crud.get_by_code(request.code)
            else:
                context.set_code(grpc.StatusCode.INVALID_ARGUMENT)
                context.set_details("Either id or code must be provided")
                return classroom_pb2.ClassroomResponse()
            
            if not classroom:
                context.set_code(grpc.StatusCode.NOT_FOUND)
                context.set_details("Classroom not found")
                return classroom_pb2.ClassroomResponse()
            
            return classroom_pb2.ClassroomResponse(
                classroom=self._build_classroom_message(classroom),
                message="Classroom retrieved successfully"
            )
            
        except Exception as e:
            logger.error(f"Error getting classroom: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return classroom_pb2.ClassroomResponse()
    
    @track_rpc_duration('UpdateClassroom')
    def UpdateClassroom(self, request, context):
        """Обновить аудиторию"""
        try:
            if not request.id:
                context.set_code(grpc.StatusCode.INVALID_ARGUMENT)
                context.set_details("Classroom ID is required")
                return classroom_pb2.ClassroomResponse()
            
            # Parse updates from map
            updates = dict(request.updates)
            
            # Update classroom
            classroom = self.crud.update(
                request.id,
                updates,
                request.updated_by if request.updated_by else None
            )
            
            if not classroom:
                context.set_code(grpc.StatusCode.NOT_FOUND)
                context.set_details("Classroom not found")
                return classroom_pb2.ClassroomResponse()
            
            # Invalidate cache
            cache.invalidate_pattern('classrooms:*')
            cache.invalidate_pattern('available:*')
            
            return classroom_pb2.ClassroomResponse(
                classroom=self._build_classroom_message(classroom),
                message="Classroom updated successfully"
            )
            
        except Exception as e:
            logger.error(f"Error updating classroom: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return classroom_pb2.ClassroomResponse()
    
    @track_rpc_duration('DeleteClassroom')
    def DeleteClassroom(self, request, context):
        """Удалить аудиторию"""
        try:
            success = self.crud.delete(
                request.id,
                request.hard_delete
            )
            
            if success:
                cache.invalidate_pattern('classrooms:*')
                cache.invalidate_pattern('available:*')
                
                return classroom_pb2.DeleteResponse(
                    success=True,
                    message="Classroom deleted successfully"
                )
            else:
                return classroom_pb2.DeleteResponse(
                    success=False,
                    message="Failed to delete classroom"
                )
                
        except Exception as e:
            logger.error(f"Error deleting classroom: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return classroom_pb2.DeleteResponse(success=False, message=str(e))
    
    @track_rpc_duration('ListClassrooms')
    def ListClassrooms(self, request, context):
        """Получить список аудиторий с фильтрацией"""
        try:
            # Validate pagination
            page = request.page if request.page else 1
            page_size = request.page_size if request.page_size else 20
            
            errors = validate_pagination(page, page_size)
            if errors:
                context.set_code(grpc.StatusCode.INVALID_ARGUMENT)
                context.set_details(f"Validation errors: {', '.join(errors)}")
                return classroom_pb2.ListClassroomsResponse()
            
            # Get classrooms
            classrooms, total = self.crud.list_classrooms(
                page=page,
                page_size=page_size,
                search_query=request.search_query if request.search_query else None,
                building_ids=list(request.building_ids) if request.building_ids else None,
                classroom_types=list(request.classroom_types) if request.classroom_types else None,
                min_capacity=request.min_capacity if request.min_capacity else None,
                max_capacity=request.max_capacity if request.max_capacity else None,
                sort_by=request.sort_by if request.sort_by else 'name',
                sort_order=request.sort_order if request.sort_order else 'ASC'
            )
            
            return classroom_pb2.ListClassroomsResponse(
                classrooms=[self._build_classroom_message(c) for c in classrooms],
                total_count=total,
                page=page,
                page_size=page_size
            )
            
        except Exception as e:
            logger.error(f"Error listing classrooms: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return classroom_pb2.ListClassroomsResponse()
    
    @track_rpc_duration('FindAvailableClassrooms')
    def FindAvailableClassrooms(self, request, context):
        """Найти свободные аудитории"""
        try:
            # Validate time slot
            errors = validate_time_slot(request.day_of_week, request.time_slot)
            if errors:
                context.set_code(grpc.StatusCode.INVALID_ARGUMENT)
                context.set_details(f"Validation errors: {', '.join(errors)}")
                return classroom_pb2.AvailableClassroomsResponse()
            
            # Check cache
            cache_key = (
                f"available:{request.day_of_week}:{request.time_slot}:"
                f"{request.min_capacity}:{request.need_projector}:"
                f"{request.need_whiteboard}:{request.need_computers}"
            )
            
            cached = cache.get(cache_key)
            if cached and config.CACHE_ENABLED:
                logger.info("Returning cached available classrooms")
                return cached
            
            # Find available classrooms
            classrooms = self.availability.find_available(
                day_of_week=request.day_of_week,
                time_slot=request.time_slot,
                min_capacity=request.min_capacity if request.min_capacity else 1,
                need_projector=request.need_projector,
                need_whiteboard=request.need_whiteboard,
                need_computers=request.need_computers,
                building_ids=list(request.building_ids) if request.building_ids else None,
                classroom_types=list(request.classroom_types) if request.classroom_types else None,
                sort_by=request.sort_by if request.sort_by else 'capacity'
            )
            
            response = classroom_pb2.AvailableClassroomsResponse(
                classrooms=[
                    classroom_pb2.AvailableClassroom(
                        classroom=self._build_classroom_message(c),
                        utilization_score=c.get('utilization_score', 0.0),
                        fully_equipped=c.get('fully_equipped', False)
                    )
                    for c in classrooms
                ]
            )
            
            # Cache response
            if config.CACHE_ENABLED:
                cache.set(cache_key, response, ttl=60)
            
            return response
            
        except Exception as e:
            logger.error(f"Error finding available classrooms: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return classroom_pb2.AvailableClassroomsResponse()
    
    @track_rpc_duration('CheckAvailability')
    def CheckAvailability(self, request, context):
        """Проверить доступность аудитории"""
        try:
            errors = validate_time_slot(request.day_of_week, request.time_slot)
            if errors:
                context.set_code(grpc.StatusCode.INVALID_ARGUMENT)
                context.set_details(f"Validation errors: {', '.join(errors)}")
                return classroom_pb2.AvailabilityResponse(is_available=False)
            
            is_available, reason = self.availability.check_availability(
                request.classroom_id,
                request.day_of_week,
                request.time_slot
            )
            
            return classroom_pb2.AvailabilityResponse(
                is_available=is_available,
                reason=reason if reason else ""
            )
            
        except Exception as e:
            logger.error(f"Error checking availability: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return classroom_pb2.AvailabilityResponse(is_available=False)
    
    @track_rpc_duration('ReserveClassroom')
    def ReserveClassroom(self, request, context):
        """Забронировать аудиторию"""
        try:
            request_data = {
                'classroom_id': request.classroom_id,
                'day_of_week': request.day_of_week,
                'time_slot': request.time_slot,
                'discipline_name': request.discipline_name
            }
            
            errors = validate_reserve_request(request_data)
            if errors:
                context.set_code(grpc.StatusCode.INVALID_ARGUMENT)
                context.set_details(f"Validation errors: {', '.join(errors)}")
                return classroom_pb2.ReserveResponse(success=False)
            
            # Валидация week (обязательное поле)
            if not request.week or request.week < 1 or request.week > 16:
                context.set_code(grpc.StatusCode.INVALID_ARGUMENT)
                context.set_details("Week is required and must be between 1 and 16")
                return classroom_pb2.ReserveResponse(success=False)
            
            week = request.week
            
            success, schedule_id, error = self.availability.reserve_classroom(
                classroom_id=request.classroom_id,
                day_of_week=request.day_of_week,
                time_slot=request.time_slot,
                week=week,
                schedule_id=request.schedule_id if request.schedule_id else None,
                discipline_name=request.discipline_name,
                teacher_name=request.teacher_name if request.teacher_name else None,
                group_name=request.group_name if request.group_name else None,
                lesson_type=request.lesson_type if request.lesson_type else None
            )
            
            if success:
                cache.invalidate_pattern('available:*')
                cache.invalidate_pattern(f'schedule:{request.classroom_id}:*')
                
            return classroom_pb2.ReserveResponse(
                success=success,
                schedule_id=schedule_id if schedule_id else 0,
                message=error if error else "Classroom reserved successfully"
            )
            
        except Exception as e:
            logger.error(f"Error reserving classroom: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return classroom_pb2.ReserveResponse(success=False, message=str(e))
    
    @track_rpc_duration('CancelReservation')
    def CancelReservation(self, request, context):
        """Отменить бронирование"""
        try:
            if request.HasField('slot'):
                success, error = self.availability.cancel_reservation(
                    request.slot.classroom_id,
                    request.slot.day_of_week,
                    request.slot.time_slot
                )
                
                if success:
                    cache.invalidate_pattern('available:*')
                    cache.invalidate_pattern(
                        f'schedule:{request.slot.classroom_id}:*'
                    )
                
                return classroom_pb2.CancelResponse(
                    success=success,
                    message=error if error else "Reservation cancelled successfully"
                )
            else:
                context.set_code(grpc.StatusCode.INVALID_ARGUMENT)
                context.set_details("Time slot must be provided")
                return classroom_pb2.CancelResponse(success=False)
                
        except Exception as e:
            logger.error(f"Error cancelling reservation: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return classroom_pb2.CancelResponse(success=False, message=str(e))
    
    @track_rpc_duration('BulkReserve')
    def BulkReserve(self, request, context):
        """Массовое бронирование"""
        try:
            reservations = [
                {
                    'classroom_id': r.classroom_id,
                    'day_of_week': r.day_of_week,
                    'time_slot': r.time_slot,
                    'schedule_id': r.schedule_id if r.schedule_id else None,
                    'discipline_name': r.discipline_name,
                    'teacher_name': r.teacher_name if r.teacher_name else None,
                    'group_name': r.group_name if r.group_name else None,
                    'lesson_type': r.lesson_type if r.lesson_type else None
                }
                for r in request.reservations
            ]
            
            result = self.availability.bulk_reserve(
                reservations,
                request.validate_only
            )
            
            if not request.validate_only:
                cache.invalidate_pattern('available:*')
                cache.invalidate_pattern('schedule:*')
            
            return classroom_pb2.BulkReserveResponse(
                successful_count=result['successful_count'],
                failed_count=result['failed_count'],
                results=[
                    classroom_pb2.ReservationResult(
                        classroom_id=r['classroom_id'],
                        success=r['success'],
                        error_message=r.get('error_message', '')
                    )
                    for r in result['results']
                ]
            )
            
        except Exception as e:
            logger.error(f"Error bulk reserving: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return classroom_pb2.BulkReserveResponse()
    
    @track_rpc_duration('GetSchedule')
    def GetSchedule(self, request, context):
        """Получить расписание аудитории"""
        try:
            week = request.week if request.week > 0 else None  # 0 = все недели
            
            schedule = self.availability.get_classroom_schedule(
                request.classroom_id,
                list(request.days_of_week) if request.days_of_week else None,
                week=week
            )
            
            total_occupied = len(schedule)
            utilization = round((total_occupied / 36) * 100, 2) if total_occupied else 0
            
            return classroom_pb2.ScheduleResponse(
                classroom_id=request.classroom_id,
                slots=[
                    classroom_pb2.ScheduleSlot(
                        day_of_week=s['day_of_week'],
                        time_slot=s['time_slot'],
                        week=s.get('week', 1),  # По умолчанию 1, если поле отсутствует (для обратной совместимости)
                        discipline_name=s.get('discipline_name', ''),
                        teacher_name=s.get('teacher_name', ''),
                        group_name=s.get('group_name', ''),
                        lesson_type=s.get('lesson_type', '')
                    )
                    for s in schedule
                ],
                total_occupied=total_occupied,
                utilization_percentage=utilization
            )
            
        except Exception as e:
            logger.error(f"Error getting schedule: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return classroom_pb2.ScheduleResponse()
    
    @track_rpc_duration('CalculateDistance')
    def CalculateDistance(self, request, context):
        """Рассчитать расстояние между аудиториями"""
        try:
            distance_data = self.distance.get_distance(
                request.from_classroom_id,
                request.to_classroom_id
            )
            
            if not distance_data:
                context.set_code(grpc.StatusCode.NOT_FOUND)
                context.set_details("Could not calculate distance")
                return classroom_pb2.DistanceResponse()
            
            return classroom_pb2.DistanceResponse(
                distance_meters=distance_data['distance_meters'],
                walking_time_seconds=distance_data['walking_time_seconds'],
                requires_building_change=distance_data['requires_building_change']
            )
            
        except Exception as e:
            logger.error(f"Error calculating distance: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return classroom_pb2.DistanceResponse()
    
    @track_rpc_duration('GetStatistics')
    def GetStatistics(self, request, context):
        """Получить статистику"""
        try:
            if request.HasField('classroom_id'):
                # Classroom-specific statistics
                stats = self.statistics.get_classroom_utilization(
                    request.classroom_id
                )
                return classroom_pb2.StatisticsResponse(
                    total_classrooms=1,
                    total_capacity=0,
                    average_utilization=stats.get('utilization_percentage', 0.0)
                )
                
            elif request.HasField('building_id'):
                # Building statistics
                stats = self.statistics.get_building_statistics(
                    request.building_id
                )
                logger.info(f"Building statistics result: {stats}")
                
                if stats.get('buildings') and len(stats['buildings']) > 0:
                    b = stats['buildings'][0]
                    logger.info(
                        f"Returning statistics: classrooms={b.get('total_classrooms', 0)}, "
                        f"capacity={b.get('total_capacity', 0)}, "
                        f"utilization={b.get('utilization_percentage', 0.0)}"
                    )
                    return classroom_pb2.StatisticsResponse(
                        total_classrooms=b.get('total_classrooms', 0),
                        total_capacity=b.get('total_capacity', 0),
                        average_utilization=b.get('utilization_percentage', 0.0),
                        by_type={}  # Building stats don't include by_type
                    )
                else:
                    # Building not found or no classrooms
                    logger.warning(f"No buildings found in statistics result for building_id={request.building_id}")
                    return classroom_pb2.StatisticsResponse(
                        total_classrooms=0,
                        total_capacity=0,
                        average_utilization=0.0,
                        by_type={}
                    )
                    
            else:
                # Overall statistics
                stats = self.statistics.get_overall_statistics()
                return classroom_pb2.StatisticsResponse(
                    total_classrooms=stats['total_classrooms'],
                    total_capacity=stats['total_capacity'],
                    average_utilization=stats['average_utilization'],
                    by_type=stats['by_type']
                )
                
        except Exception as e:
            logger.error(f"Error getting statistics: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return classroom_pb2.StatisticsResponse()
    
    # ============ BUILDINGS ============
    
    @track_rpc_duration('CreateBuilding')
    def CreateBuilding(self, request, context):
        """Создать здание"""
        try:
            building_data = {
                'name': request.name,
                'short_name': request.short_name or None,
                'code': request.code or None,
                'address': request.address or None,
                'campus': request.campus or None,
                'latitude': request.latitude if request.latitude else None,
                'longitude': request.longitude if request.longitude else None,
                'total_floors': request.total_floors or 1,
                'has_elevator': request.has_elevator
            }
            
            result = building_service.create_building(building_data)
            
            # Get full building data
            building = building_service.get_building(result['id'])
            
            if not building:
                context.set_code(grpc.StatusCode.INTERNAL)
                context.set_details("Failed to retrieve created building")
                return classroom_pb2.BuildingResponse()
            
            building_msg = self._build_building_message(building)
            
            return classroom_pb2.BuildingResponse(
                building=building_msg,
                message="Building created successfully"
            )
            
        except Exception as e:
            logger.error(f"CreateBuilding error: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return classroom_pb2.BuildingResponse()
    
    @track_rpc_duration('GetBuilding')
    def GetBuilding(self, request, context):
        """Получить здание по ID"""
        try:
            building = building_service.get_building(request.building_id)
            
            if not building:
                context.set_code(grpc.StatusCode.NOT_FOUND)
                context.set_details("Building not found")
                return classroom_pb2.BuildingResponse()
            
            building_msg = self._build_building_message(building)
            
            return classroom_pb2.BuildingResponse(
                building=building_msg,
                message="Building retrieved successfully"
            )
            
        except Exception as e:
            logger.error(f"GetBuilding error: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return classroom_pb2.BuildingResponse()
    
    @track_rpc_duration('ListBuildings')
    def ListBuildings(self, request, context):
        """Получить список зданий"""
        try:
            buildings = building_service.list_buildings()
            
            building_msgs = [
                self._build_building_message(b) for b in buildings
            ]
            
            return classroom_pb2.BuildingsResponse(
                buildings=building_msgs,
                total_count=len(buildings),
                message="Buildings retrieved successfully"
            )
            
        except Exception as e:
            logger.error(f"ListBuildings error: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return classroom_pb2.BuildingsResponse()
    
    def _build_building_message(self, data: dict):
        """Построить Building protobuf message"""
        if classroom_pb2 is None:
            return None
        
        return classroom_pb2.Building(
            id=data.get('id', 0),
            name=data.get('name', ''),
            short_name=data.get('short_name', ''),
            code=data.get('code', ''),
            address=data.get('address', ''),
            campus=data.get('campus', ''),
            latitude=float(data.get('latitude', 0.0)) if data.get('latitude') else 0.0,
            longitude=float(data.get('longitude', 0.0)) if data.get('longitude') else 0.0,
            total_floors=data.get('total_floors', 1),
            has_elevator=data.get('has_elevator', False),
            created_at=str(data.get('created_at', '')),
            updated_at=str(data.get('updated_at', ''))
        )
    
    @track_rpc_duration('UpdateBuilding')
    def UpdateBuilding(self, request, context):
        """Обновить здание"""
        try:
            # Build update dict from request (only non-empty fields)
            updates = {}
            
            if request.name:
                updates['name'] = request.name
            if request.short_name:
                updates['short_name'] = request.short_name
            if request.code:
                updates['code'] = request.code
            if request.address:
                updates['address'] = request.address
            if request.campus:
                updates['campus'] = request.campus
            if request.latitude != 0.0:
                updates['latitude'] = request.latitude
            if request.longitude != 0.0:
                updates['longitude'] = request.longitude
            if request.total_floors > 0:
                updates['total_floors'] = request.total_floors
            # has_elevator is bool, include if explicitly set
            if request.HasField('has_elevator'):
                updates['has_elevator'] = request.has_elevator
            
            if not updates:
                context.set_code(grpc.StatusCode.INVALID_ARGUMENT)
                context.set_details("No fields to update")
                return classroom_pb2.BuildingResponse()
            
            result = building_service.update_building(
                request.building_id,
                updates
            )
            
            if not result:
                context.set_code(grpc.StatusCode.NOT_FOUND)
                context.set_details("Building not found")
                return classroom_pb2.BuildingResponse()
            
            building_msg = self._build_building_message(result)
            
            return classroom_pb2.BuildingResponse(
                building=building_msg,
                message="Building updated successfully"
            )
            
        except Exception as e:
            error_msg = str(e)
            logger.error(f"UpdateBuilding error: {e}", exc_info=True)
            
            if "not found" in error_msg.lower():
                context.set_code(grpc.StatusCode.NOT_FOUND)
                context.set_details(error_msg)
            else:
                context.set_code(grpc.StatusCode.INTERNAL)
                context.set_details(str(e))
            return classroom_pb2.BuildingResponse()
    
    @track_rpc_duration('DeleteBuilding')
    def DeleteBuilding(self, request, context):
        """Удалить здание"""
        try:
            success = building_service.delete_building(
                request.building_id
            )
            
            if success:
                return classroom_pb2.DeleteResponse(
                    success=True,
                    message="Building deleted successfully"
                )
            else:
                context.set_code(grpc.StatusCode.INTERNAL)
                context.set_details("Failed to delete building")
                return classroom_pb2.DeleteResponse(success=False)
                
        except Exception as e:
            error_msg = str(e)
            logger.error(f"DeleteBuilding error: {e}", exc_info=True)
            
            if "Cannot delete building" in error_msg:
                context.set_code(grpc.StatusCode.FAILED_PRECONDITION)
                context.set_details(error_msg)
            elif "not found" in error_msg.lower():
                context.set_code(grpc.StatusCode.NOT_FOUND)
                context.set_details(error_msg)
            else:
                context.set_code(grpc.StatusCode.INTERNAL)
                context.set_details(str(e))
            return classroom_pb2.DeleteResponse(success=False)
    
    @track_rpc_duration('HealthCheck')
    def HealthCheck(self, request, context):
        """Проверка здоровья сервиса"""
        return classroom_pb2.HealthCheckResponse(
            status="healthy",
            version=config.SERVICE_VERSION
        )

